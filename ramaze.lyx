#LyX 1.5.5 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{color}
\usepackage{alltt}

\newcommand{\hlstd}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\hlnum}[1]{\textcolor[rgb]{0.16,0.16,1}{#1}}
\newcommand{\hlesc}[1]{\textcolor[rgb]{1,0,1}{#1}}
\newcommand{\hlstr}[1]{\textcolor[rgb]{1,0,0}{#1}}
\newcommand{\hldstr}[1]{\textcolor[rgb]{0.51,0.51,0}{#1}}
\newcommand{\hlslc}[1]{\textcolor[rgb]{0.51,0.51,0.51}{\it{#1}}}
\newcommand{\hlcom}[1]{\textcolor[rgb]{0.51,0.51,0.51}{\it{#1}}}
\newcommand{\hldir}[1]{\textcolor[rgb]{0,0.51,0}{#1}}
\newcommand{\hlsym}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\hlline}[1]{\textcolor[rgb]{0.33,0.33,0.33}{#1}}
\newcommand{\hlkwa}[1]{\textcolor[rgb]{0,0,0}{\bf{#1}}}
\newcommand{\hlkwb}[1]{\textcolor[rgb]{0.51,0,0}{#1}}
\newcommand{\hlkwc}[1]{\textcolor[rgb]{0,0,0}{\bf{#1}}}
\newcommand{\hlkwd}[1]{\textcolor[rgb]{0,0,0.51}{#1}}
\end_preamble
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize 12
\spacing single
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 2.5cm
\topmargin 2.5cm
\rightmargin 2.5cm
\bottommargin 2.5cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language polish
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Ramaze
\end_layout

\begin_layout Author
Michael Fellinger
\end_layout

\begin_layout Standard
Ramaze is a simple but powerful web application development framework.
 This book is an in-depth walk-through of Ramaze's features and behaviour.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Subsection
About Ramaze
\end_layout

\begin_layout Standard
Ramaze is a modular web application framework, it provides you with just
 about everything to make your daily development simple and fun.
\end_layout

\begin_layout Standard
Making programming fun is a concept popularized by the Ruby programming
 language in which Ramaze is written.
 This document assumes at least basic knowledge about Ruby.
 If you do not know what Ruby is yet, visit
\begin_inset LatexCommand url
target "http://ruby-lang.org"

\end_inset

 and find out, but beware, it may change your life.
\end_layout

\begin_layout Subsubsection
Important Links
\end_layout

\begin_layout Standard
Naturally for an open source web framework, apart from reading the source
 most help can be found online.
 So here are some links to provide more information on all the topics covered
 in this book.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand url
target "http://ramaze.net"

\end_inset

 provides further documentation, screencasts, links and news.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand url
target "http://ramaze.googlegroups.com"

\end_inset

 hosts the mailing list for discussion with the developers and users of
 the framework.
\end_layout

\begin_layout Subsection
About the author
\end_layout

\begin_layout Standard
Michael Fellinger (a.k.a manveru) is initiator and core developer of the Ramaze
 framework.
\end_layout

\begin_layout Standard
His programming language of choice is, as you might have guessed already,
 Ruby.
\end_layout

\begin_layout Standard
Michael lives in Tokyo/Japan since 2006, but is Austrian, whenever you find
 strange English in this article, blame it on the daily influence of Engrish
 and that German is his native language.
\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Section
Ramaze
\end_layout

\begin_layout Standard
As mentioned above, Ramaze is a web application framework, but also features
 a readable open source codebase licensed under the Ruby license (optional
 GPLv2).
\end_layout

\begin_layout Standard
The strenghts of Ramaze, as described by its users, are a free style of
 development, enjoying all the benefits of the underlying Ruby programming
 language without having the library getting into your way of doing things
 but instead helping you along as you require it.
\end_layout

\begin_layout Subsection
Installation Prerequisits
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
Ruby 
\begin_inset LatexCommand url
target "http://ruby-lang.org"

\end_inset


\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
Rubygems 
\begin_inset LatexCommand url
target "http://rubygems.org"

\end_inset


\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
rack 
\begin_inset LatexCommand url
target "http://rack.rubyforge.org"

\end_inset


\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
ramaze 
\begin_inset LatexCommand url
target "http://ramaze.net"

\end_inset


\end_layout

\begin_layout Subsection
Installing a specific version
\end_layout

\begin_layout Standard
Installing Ramaze should be very simple on most systems.
 I will cover a couple of ways here.
\end_layout

\begin_layout Subsubsection
On Windows
\end_layout

\begin_layout Subsubsection
On OSX
\end_layout

\begin_layout Subsubsection
On Linux
\end_layout

\begin_layout Standard
Issue your package manager to install a package commonly called
\begin_inset Quotes pld
\end_inset

rubygems
\begin_inset Quotes prd
\end_inset


\end_layout

\begin_layout Subparagraph
ArchLinux
\end_layout

\begin_layout LyX-Code
$ pacman -S rubygems
\end_layout

\begin_layout Subparagraph
Debian
\end_layout

\begin_layout LyX-Code
$ apt-get install rubygems
\end_layout

\begin_layout Standard
Now that you have rubygems installed, there are a few useful steps to make
 rubygems run without root permissions by installing them into your home
 or otherwise by you controlled directory.
\end_layout

\begin_layout Standard
I strongly recommend doing this as it simplifies further diving into the
 ruby ecosystem without having to use sudo or switch to root via su.
\end_layout

\begin_layout Standard
Simply add following lines to your ~/.bashrc or ~/.zshrc
\end_layout

\begin_layout LyX-Code
export RUBYOPT=-rubygems
\end_layout

\begin_layout LyX-Code
export GEM_HOME="$HOME/.gems"
\end_layout

\begin_layout LyX-Code
export GEM_PATH="$GEM_HOME"
\end_layout

\begin_layout LyX-Code
export PATH="$HOME/.gems/bin:$PATH"
\end_layout

\begin_layout Standard
Once you have done that you can simply run
\end_layout

\begin_layout LyX-Code
gem install ramaze
\end_layout

\begin_layout Standard
And Ramaze will be installed.
\end_layout

\begin_layout Subsubsection
On Linux (manual)
\end_layout

\begin_layout Standard
Download and install from http://rubygems.org
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
Visit 
\begin_inset LatexCommand url
target "http://rubyforge.org/frs/?group_id=126"

\end_inset


\end_layout

\begin_layout Standard
and download the latest version as tgz.
\end_layout

\begin_layout Subsection
Installing the development version
\end_layout

\begin_layout Standard
Ramaze is developed in a git repository, so if you want to get the latest
 source you can simply get your own copy.
 Please note that, since all our commits are checked by the spec suite before
 they get into the official repository, they are generally safe for production
 use and even recommended since recent security and code flaws have been
 applied.
\end_layout

\begin_layout Standard
Installing the gem is only recommended if you want to have a version of
 ramaze that
\begin_inset Quotes pld
\end_inset

just works
\begin_inset Quotes prd
\end_inset

 or if you have only the ability to use ramaze through the gem (possible
 on some system setups).
\end_layout

\begin_layout Subsubsection
Latest as tarball
\end_layout

\begin_layout Standard
You can download a tarball directly from github, the location of our Ramaze
 repository is at 
\begin_inset LatexCommand htmlurl
target "http://github.com/manveru/ramaze"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Getting git
\end_layout

\begin_layout Standard
Git is available on most Linux distributions
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
TODO
\end_layout

\begin_layout Standard
Write instructions for Linux, OSX, Windows
\end_layout

\begin_layout Standard
link to git homepage and their installation instructions?
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Clone the repository
\end_layout

\begin_layout Standard
Cloning the repository, a.k.a getting your own copy, is really simple once
 you have installed git.
\end_layout

\begin_layout LyX-Code
$ git clone git://github.com/manveru/ramaze
\end_layout

\begin_layout Subsubsection
Setting up your environment after installation
\end_layout

\begin_layout Standard
Now that you have the latest version of Ramaze, you have to tell Ruby how
 to find it.
 One of the simplest ways is to add a file called
\begin_inset Quotes pld
\end_inset

ramaze.rb
\begin_inset Quotes prd
\end_inset

 in your site_ruby directory.
\end_layout

\begin_layout LyX-Code
$ echo 'export RUBYLIB="/path/to/ramaze/lib/:$RUBYLIB"' >> ~/.bashrc
\end_layout

\begin_layout Standard
This way, everytime you say
\begin_inset Quotes pld
\end_inset

require 'ramaze'
\begin_inset Quotes prd
\end_inset

 in your code, it will first require the ramaze.rb in the site_ruby directory,
 which in turn requires the ramaze.rb from your development version.
\end_layout

\begin_layout Section
Basic Usage
\end_layout

\begin_layout Subsection
Hello, World!
\end_layout

\begin_layout Standard
A short introductionary example is always
\begin_inset Quotes pld
\end_inset

Hello world
\begin_inset Quotes prd
\end_inset

, in Ramaze this looks like following.
\end_layout

\begin_layout LyX-Code
\begin_inset External
	template RubyCode
	filename source/hello_world.rb

\end_inset


\end_layout

\begin_layout Standard
First we require rubygems, the package managing wrapper that allows us to
 require the ramaze library and framework.
 Next we define a Controller and method that will show up when accessing
\begin_inset Quotes pld
\end_inset

http://localhost:7000/
\begin_inset Quotes prd
\end_inset

, 7000 being the default port of Ramaze.
\end_layout

\begin_layout Subsection
Configuration
\end_layout

\begin_layout Standard
Configuration is mainly done by the Ramaze::Global singleton.
 It's an instance of Option::Holder, containing a rather large list of options
 and their defaults.
 Every option is documented in minimal style and the defaults should make
 clear in most cases how to set these options.
\end_layout

\begin_layout Standard
Configuration can be done either from Environment variables or command-line
 arguments or directly in your source.
\end_layout

\begin_layout Standard
Let's see the different ways, three variations of how to set your port in
 source first.
\end_layout

\begin_layout LyX-Code
\begin_inset External
	template RubyCode
	filename source/global/various_source.rb

\end_inset


\end_layout

\begin_layout Standard
now by commandline arguments
\end_layout

\begin_layout LyX-Code
$ ruby start.rb --port 8080
\end_layout

\begin_layout Standard
and finally using an environment variable
\end_layout

\begin_layout LyX-Code
$ RAMAZE_PORT=8080 ruby start.rb
\end_layout

\begin_layout Subsection
Application with multiple files
\end_layout

\begin_layout Standard
The convention for larger applications consists of a basic (voluntary) directory
 structure.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
Find a way to dynamically insert the output of `ls -R lib/proto`.
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
/
\end_layout

\begin_deeper
\begin_layout LyX-Code
start.rb
\end_layout

\begin_layout LyX-Code
ramaze.ru
\end_layout

\begin_layout LyX-Code
public/
\end_layout

\begin_deeper
\begin_layout LyX-Code
favicon.ico
\end_layout

\begin_layout LyX-Code
robots.txt
\end_layout

\end_deeper
\begin_layout LyX-Code
model/
\end_layout

\begin_deeper
\begin_layout LyX-Code
user.rb
\end_layout

\end_deeper
\begin_layout LyX-Code
view/
\end_layout

\begin_deeper
\begin_layout LyX-Code
index.xhtml
\end_layout

\begin_layout LyX-Code
user/
\end_layout

\begin_deeper
\begin_layout LyX-Code
index.xhtml
\end_layout

\begin_layout LyX-Code
view.xhtml
\end_layout

\begin_layout LyX-Code
new.xhtml
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code
controller/
\end_layout

\begin_deeper
\begin_layout LyX-Code
main.rb
\end_layout

\begin_layout LyX-Code
user.rb
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
Following this layout is fully up to you, but it is recommended to make
 it easier for other people to jump right into your code and understand
 things.
\end_layout

\begin_layout Subsubsection
Some directory conventions in detail
\end_layout

\begin_layout Standard
There are two special cases you should be aware of before starting, /public
 and /view are defaults in Ramaze, set in Ramaze::Global.public_root and
 Ramaze::Global.view_root respectively, they are relative to Ramaze::Global.root
\end_layout

\begin_layout Standard
To illustrate this, see following example:
\end_layout

\begin_layout LyX-Code
\begin_inset External
	template RubyCode
	filename source/global/directory_convention_inspect.rb

\end_inset


\end_layout

\begin_layout Standard
In practical terms this means that templates are found in the /view directory
 while static files are served from /public
\end_layout

\begin_layout Standard
The rest of the conventions are not connected to any defaults and you will
 have to manually require your .rb files from start.rb, or however your file
 is named that contains
\begin_inset Quotes pld
\end_inset

Ramaze.start
\begin_inset Quotes prd
\end_inset

.
\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Section
Ramaze::Controller
\end_layout

\begin_layout Subsection
What, exactly, is a Controller anyway?
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
The title of this section refers to a popular discussion on The Wiki, they
 talk about how the term MVC (and in particular the Controller part) has
 changed meaning and is totally abused today.
\end_layout

\begin_layout Standard
This is not very relevant for us, since the new terminology is quite popular
 already, but it makes for a great pun.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first thing you will encounter when starting out with Ramaze is the
 Controller.
 This is because the Controller is the central structure in most web application
s and for that reason you should know as much as possible about it.
\end_layout

\begin_layout Standard
To start out, let's take a look at the basic structure of a usual Controller
 with a hello world example.
\end_layout

\begin_layout LyX-Code
\begin_inset External
	template RubyCode
	filename source/controller/main_controller.rb

\end_inset


\end_layout

\begin_layout Standard
So we have a class MainController that inherits from Ramaze::Controller,
 I won't go into details yet what exactly this inheritance means, but it
 basically integrates your new class into your application.
\end_layout

\begin_layout Standard
What you see next is a method called index, containing a simple String.
\end_layout

\begin_layout Standard
To fully understand this snippet we will have to understand the concept
 of mapping in Ramaze.
 If you are familiar with other web frameworks, you will know about routing,
 and for those of you who don't, let me explain routing real quick, since
 it's the principle applied here as well.
\end_layout

\begin_layout Standard
So routing basically means, when you get a request from a client to ``/user/song
s'', the routing will see if you have defined any routes matching this path
 and executes whatever you specified as the result.
\end_layout

\begin_layout Standard
What Ramaze does with mapping is a little bit more sophisticated in order
 to lift work off the shoulders of the programmer and only make him do manual
 routing to refine the results of this automatic procedure.
\end_layout

\begin_layout Standard
So given a Controller named UserController, Ramaze will route to it with
 the path ,,/user'', UserNameController would be put at ,,/user_name'' and
 so on.
 In this case we have picked the only exception, that is MainController
 and is mapped at ,,/'' by default.
\end_layout

\begin_layout Standard
We will see in the next example how to change this default mapping, since
 defaults may be good, but nothing beats configurability when needed.
\end_layout

\begin_layout Subsection
Remapping
\end_layout

\begin_layout Standard
In order to change the default mapping, you can simply use the Controller::map(p
ath, [path2, ...]) method.
 This also allows you to map one Controller on multiple paths.
\end_layout

\begin_layout LyX-Code
\begin_inset External
	template RubyCode
	filename source/controller/change_mapping.rb

\end_inset


\end_layout

\begin_layout Standard
This example simply shows how you can use the map method, but let's see
 a nicer way to do the same using the default mapping.
\end_layout

\begin_layout LyX-Code
\begin_inset External
	template RubyCode
	filename source/controller/default_mapping_1.rb

\end_inset


\end_layout

\begin_layout Standard
So instead of defining a Controller that is by default mapped to
\begin_inset Quotes pld
\end_inset

/
\begin_inset Quotes prd
\end_inset

 and remapping to
\begin_inset Quotes pld
\end_inset

/article
\begin_inset Quotes prd
\end_inset

, we can just name it ArticleController and Ramze will take the part of
 your classes name before
\begin_inset Quotes pld
\end_inset

Controller
\begin_inset Quotes prd
\end_inset

 and convert it to a mapping by doing a simple snake case transformation.
\end_layout

\begin_layout Standard
Sticking to this kind of defaults makes your code a lot more readable, as
 people know which Controller will map to which URL without even checking
 first.
\end_layout

\begin_layout Subsection
Controller class methods
\end_layout

\begin_layout Subsubsection
Controller::startup
\end_layout

\begin_layout Subsubsection
Controller::map
\end_layout

\begin_layout Subsubsection
Controller::at
\end_layout

\begin_layout Subsubsection
Controller::layout
\end_layout

\begin_layout Subsubsection
Controller::template
\end_layout

\begin_layout Subsubsection
Controller::check_path
\end_layout

\begin_layout Subsubsection
Controller::engine
\end_layout

\begin_layout Subsubsection
Controller::current
\end_layout

\begin_layout Subsubsection
Controller::handle
\end_layout

\begin_layout Subsubsection
Controller::relevant_ancestors
\end_layout

\begin_layout Subsubsection
Controller::render
\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Section
Ramaze::Current
\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Section
Ramaze::Trinity
\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Section
Ramaze::Session
\end_layout

\begin_layout Standard
Sessions are an essential part of most dynamic web applications and so Ramaze
 makes it very simple to use them.
 We will see how to use the automated sessions, handle cookies manually
 and change the backend where session information is stored on the serverside.
\end_layout

\begin_layout Subsection
What are sessions
\end_layout

\begin_layout Standard
Although I said that they are essential, some people may not yet be familiar
 with sessions and what use cases exist for them, so let's take a look at
 a simple application using sessions first.
\end_layout

\begin_layout LyX-Code
\begin_inset External
	template RubyCode
	filename source/session/what_are_sessions_1.rb

\end_inset


\end_layout

\begin_layout Standard
In this, we select a random language key that we then set in our session.
 The browser that hits the index action will from now on always have this
 language associated to it and you can see it in your controller and templates
 inside the session object.
\end_layout

\begin_layout Standard
Now a few details on how this works exactly.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
We're working on a improvment of the session system, so they are acting
 in a lazy manner and default to storing information directly in the cookies
 rather than being referred to with a simple key and stored serverside.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
On every request, as we mentioned in the chapter about Ramaze::Current already,
 a Session is initialized and put into Thread.current[:session].
 This makes it possible to access the session during the whole request.
 The initialization will set a cookie in the current response, setting the
 key 
\begin_inset Quotes pld
\end_inset

_ramaze_session_id
\begin_inset Quotes prd
\end_inset

 with a unique value representing the key to the data stored on the server.
\end_layout

\begin_layout Standard
Cookies are basically a part of the response headers, a simple string that
 is being sent back and forth during the request/response cycle.
 Everytime a browser sends a request it will also send the cookie in the
 header with it, that way we can look up which data belongs to that browser.
\end_layout

\begin_layout Standard
In Ramaze this data is stored in a cache, at the time of writing the two
 most commonly used ones are MemcachedCache and MemoryCache.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
This, i'd like to change in the future as well, putting them in the Ramaze::Cach
e namespace.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Although they may sound similar, they are quite different concepts, MemoryCache
 equals a Ruby Hash, it doesn't put any restrains on the kind or amount
 of data stored, which can become problematic for larger applications.
 MemcachedCache on the other hand utilizes the MemCache library to communicate
 with an (usually) local memcache daemon that handles caching of key/value
 pairs in namespaces.
 It allows you to control the way caching happens very well, one commonly
 used option is to put a limit on the overall amount of data stored.
 However, old data is thrown away if your application tries to cache more
 data than allowed.
\end_layout

\begin_layout Standard
There is a third way which was contributed recently, to utilize the Sequel
 ORM and use a relational database for storage, which gives both control
 and persistence as old data is never thrown away unless explicitly ordered
 to do so.
\end_layout

\begin_layout Subsection
Configuration
\end_layout

\begin_layout Standard
A number of options lets you decide how to use sessions and their behaviour.
\end_layout

\begin_layout Standard
To disable them, simply assign:
\end_layout

\begin_layout LyX-Code
Ramaze::Global.sessions = false
\end_layout

\begin_layout Standard
This will give you some speedup and less data being transferred between
 server and client, it does not affect the ability to manually set cookies
 in the response.
\end_layout

\begin_layout Standard
To change the backend for the session cache only (as opposed to it for all
 caches in your Ramaze, we talk about that in the Ramaze::Cache section)
 do following:
\end_layout

\begin_layout LyX-Code
Ramaze::Global.cache_alternative[:sessions] = Ramaze::MemcachedCache
\end_layout

\begin_layout Standard
Please make sure you have the memcached server running before starting an
 application with this setting.
\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Section
Ramaze::Request
\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Section
Ramaze::Response
\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Section
Ramaze::Helper
\end_layout

\begin_layout Standard
Helpers are modules for inclusion into controllers or other classes.
\end_layout

\begin_layout Subsection
Using a helper
\end_layout

\begin_layout LyX-Code
\begin_inset External
	template RubyCode
	filename source/helper/using_helper_1.rb

\end_inset


\end_layout

\begin_layout Subsection
Rules for helpers
\end_layout

\begin_layout Standard
Methods are private.
\end_layout

\begin_layout Subsection
How to create your own helper
\end_layout

\begin_layout Standard
Creating helpers is simple.
\end_layout

\begin_layout LyX-Code
\begin_inset External
	template RubyCode
	filename source/helper/simley_helper_1.rb

\end_inset


\end_layout

\begin_layout Subsubsection
Exposing methods to routing
\end_layout

\begin_layout Standard
By adding an helper module to the Ramaze::Helper::LOOKUP Set it's possible
 to add the module to the lookup for methods together with the Ramaze::Controlle
r.
 Conflicts of method names in Helper and Controller will prefer the Controller,
 following the same rules as Ruby inheritance.
 
\end_layout

\begin_layout LyX-Code
\begin_inset External
	template RubyCode
	filename source/helper/exposing_methods_to_routing.rb

\end_inset


\end_layout

\begin_layout Standard
In this example we expose the public method Locale#locale (Ruby methods
 are public by default).
 So in your application your can just use the helper and when the client
 visits the /locale/en route the session will reflect this choice.
\end_layout

\begin_layout Standard
Please note that this code doesn't include a redirect_referrer call since
 we may be using it within our own codebase in the middle of a method.
\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Section
Ramaze::Action
\end_layout

\begin_layout Standard
Action is one of the core parts of Ramaze, a recipe for rendering combinations
 of controllers, methods and templates.
\end_layout

\begin_layout Subsection
What is an Action
\end_layout

\begin_layout Standard
An Action, at the lowest level, is a Struct with following members:
\end_layout

\begin_layout Subsubsection
Action#method
\end_layout

\begin_layout Standard
Refers to the name of the method to be invoked before a template is evaluated.
\end_layout

\begin_layout Standard
The return value of the method is kept as the result of Action#render if
 there is no Action#template.
\end_layout

\begin_layout Subsubsection
Action#params
\end_layout

\begin_layout Standard
The parameter are part of the #__send__ to Action#method.
 You can visualize this as:
\end_layout

\begin_layout LyX-Code
if method = action.method
\end_layout

\begin_layout LyX-Code
  action.instance.__send__(method, *action.params)
\end_layout

\begin_layout LyX-Code
end
\end_layout

\begin_layout Standard
In Lisp/Scheme terms, they are being applied.
\end_layout

\begin_layout Standard
Please note that the params are given as Strings due to the fact that they
 are extracted from the URI of the HTTP method and so Ramaze has no chance
 of determining what kind of Object this should represent.
\end_layout

\begin_layout Subsubsection
Action#template
\end_layout

\begin_layout Standard
If there is a template found during the procedure of finding a fitting Action
 for the given request, this member is set to the relative path from your
 Global.view_root or Controller.view_root directory.
 The template is evaluated unless the templating engine is set to :None
 and the result of this evaluation is set as the response.body.
\end_layout

\begin_layout Subsubsection
Action#controller
\end_layout

\begin_layout Standard
Points to the controller this Action operates on, also see Action#instance.
\end_layout

\begin_layout Subsubsection
Action#path
\end_layout

\begin_layout Standard
A String represenation of the Action without params, generally it's the
 name of the method or (if no method but a template found) the name of the
 template without extension.
 It's used for different kinds of hooks.
\end_layout

\begin_layout Subsubsection
Action#binding
\end_layout

\begin_layout Standard
The binding to the Action#instance, obtained by doing an instance_eval{
 binding} on it.
 This is only done when the binding hasn't been set yet.
\end_layout

\begin_layout Subsubsection
Action#engine
\end_layout

\begin_layout Standard
Refers to the templating engine that this Action is passed to when Action#render
 is called.
\end_layout

\begin_layout Subsubsection
Action#instance
\end_layout

\begin_layout Standard
Instance of the Controller, lazily obtained through Action#controller.new
 on access of this member.
 Note that this is also invoked as a dependency of Action#binding.
\end_layout

\begin_layout Subsection
Create an Action
\end_layout

\begin_layout Standard
Creating an Action can be verbose and is usually not required outside the
 direct proximity within the codeflow.
\end_layout

\begin_layout LyX-Code
\begin_inset External
	template RubyCode
	filename source/action/create_an_action_1.rb

\end_inset


\end_layout

\begin_layout Subsection
Render an Action
\end_layout

\begin_layout Standard
We did all this just to render an Action, so let's do that already.
\end_layout

\begin_layout LyX-Code
\begin_inset External
	template RubyCode
	filename source/action/render_an_action_1.rb

\end_inset


\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Section
Ramaze::Template
\end_layout

\begin_layout Subsection
Engines
\end_layout

\begin_layout Subsection
Ezamar
\end_layout

\begin_layout Standard
Ezamar is the default templating engine shipped with Ramaze, it's a very
 simple implementation but offers you most things you will demand from templatin
g.
\end_layout

\begin_layout Standard
One of the advantages of Ezamar is quite fast execution based on the optimized
 String interpolation in Ruby.
\end_layout

\begin_layout Standard
Also, your templates will work out of the box, you don't have to install
 anything besides Ramaze.
\end_layout

\begin_layout Subsubsection
Syntax
\end_layout

\begin_layout Standard
Output is done by using #{} syntax, the last expression inside the parenthesis
 is interpolated in the final template.
\end_layout

\begin_layout Standard
The PI (Processing Instruction) is <?r ?>, r standing for Ruby, In future
 more PIs may become available.
\end_layout

\begin_layout Standard
To summarize:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
#{ (expr) }
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Interpolates like in normal Ruby String and shows in result.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
<?r (expr) ?>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Only execute; <expression> is sourrounded by semicolon.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
Usage
\end_layout

\begin_layout Standard
As an example, let's see hello world using all basic features of this engine.
\end_layout

\begin_layout LyX-Code
<html>
\end_layout

\begin_layout LyX-Code
  <head><title>Hello, World!</title></head>
\end_layout

\begin_layout LyX-Code
  <body>
\end_layout

\begin_layout LyX-Code
    <h1>Hello, World!</h1>
\end_layout

\begin_layout LyX-Code
    <?r 10.times do |i| ?>
\end_layout

\begin_layout LyX-Code
      <p>#{ordinal(i)} times i've said hello</p>
\end_layout

\begin_layout LyX-Code
    <?r end ?>
\end_layout

\begin_layout LyX-Code
  </body>
\end_layout

\begin_layout LyX-Code
</html>
\end_layout

\begin_layout Subsection
Erubis
\end_layout

\begin_layout Standard
Erubis is an implementation of eRuby, giving you the well known ERB syntax.
\end_layout

\begin_layout Standard
It is very fast, around three times faster than ERB and even 10% faster
 than eruby.
\end_layout

\begin_layout Standard
Other features are
\end_layout

\begin_layout Itemize
Multi-language support (Ruby/PHP/C/Java/Scheme/Perl/Javascript)
\end_layout

\begin_layout Itemize
Auto escaping support
\end_layout

\begin_layout Itemize
Auto trimming spaces around '<% %>'
\end_layout

\begin_layout Itemize
Embedded pattern changeable (default '<% %>')
\end_layout

\begin_layout Itemize
Enable to handle Processing Instructions (PI) as embedded pattern (ex.
 '<?rb ...
 ?>')
\end_layout

\begin_layout Itemize
Context object available and easy to combine eRuby template with YAML datafile
\end_layout

\begin_layout Itemize
Print statement available
\end_layout

\begin_layout Itemize
Easy to extend and customize in subclass
\end_layout

\begin_layout Standard
Erubis is implemented in pure Ruby, so it works on most implemenations of
 the language.
 According to their dependencies it requires Ruby 1.8 or higher.
\end_layout

\begin_layout Subsubsection*
Syntax
\end_layout

\begin_layout Standard
Erubis provides you default ERB syntax, PIs are inside <% %>, output is
 done by <%= %>
\end_layout

\begin_layout Standard
Summary:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features>
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
<% (expr) %>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Execute expression, ignore result
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
<%= (expr) %>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Interpolate last expressions result
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
<?rb (expr) %>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Execute expression, ignore result
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection*
Usage
\end_layout

\begin_layout LyX-Code
<html>
\end_layout

\begin_layout LyX-Code
  <head><title>Hello, World!</title></head>
\end_layout

\begin_layout LyX-Code
  <body>
\end_layout

\begin_layout LyX-Code
    <h1>Hello, World!</h1>
\end_layout

\begin_layout LyX-Code
    <% 10.times do |i| %>
\end_layout

\begin_layout LyX-Code
      <p><%= ordinal(i) %> times i've said hello</p>
\end_layout

\begin_layout LyX-Code
    <% end %>
\end_layout

\begin_layout LyX-Code
  </body>
\end_layout

\begin_layout LyX-Code
</html>
\end_layout

\begin_layout Subsection
Haml
\end_layout

\begin_layout Standard
Haml is a templating engine for (X)HTML, designed to make it both easier
 and more pleasant to code your documents.
\end_layout

\begin_layout Standard
It attempts to eliminate redundancy, reflecting the underlying structure
 that the document represents, and providing elegant, easily understandable
 but powerful syntax.
\end_layout

\begin_layout Standard
It's closely related to the Sass templating engine also supported by Ramaze.
\end_layout

\begin_layout Subsubsection*
Syntax
\end_layout

\begin_layout Standard
Haml syntax is more involved as it replaces conventional HTML tags completely
 and providing its own indentation-based alternative.
\end_layout

\begin_layout Standard
The way to create tags can be shortly summarized with
\end_layout

\begin_layout LyX-Code
%tagname{ :attr1 => 'value1', :attr2 => 'value2' } Contents
\end_layout

\begin_layout LyX-Code
# Equivalent in HTML:
\end_layout

\begin_layout LyX-Code
<tagname attr1='value1' attr2='value2'>Contents</tagname>
\end_layout

\begin_layout Standard
There are shortcuts, especially for the
\emph on
<div>
\emph default
 tag:
\end_layout

\begin_layout LyX-Code
#foo Bar
\end_layout

\begin_layout LyX-Code
# Equivalent in HTML:
\end_layout

\begin_layout LyX-Code
<div id='foo'>Bar</div>
\end_layout

\begin_layout Standard
To nest tags, just adjust their indentation:
\end_layout

\begin_layout LyX-Code
#foo Bar
\end_layout

\begin_layout LyX-Code
  #bar Foo
\end_layout

\begin_layout LyX-Code
# in HTML:
\end_layout

\begin_layout LyX-Code
<div id='foo'>Bar
\end_layout

\begin_layout LyX-Code
  <div id='bar'>Foo</div>
\end_layout

\begin_layout LyX-Code
</div>
\end_layout

\begin_layout Standard
Which already shows you how this can be a very powerful way to write your
 templates.
\end_layout

\begin_layout Standard
An example embedding Ruby code:
\end_layout

\begin_layout LyX-Code
%p Date/Time:
\end_layout

\begin_layout LyX-Code
  - now = DateTime.now
\end_layout

\begin_layout LyX-Code
  %strong= now
\end_layout

\begin_layout LyX-Code
  - if now > DateTime.parse('December 31, 2006')
\end_layout

\begin_layout LyX-Code
    = 'Happy new ' + 'year!'
\end_layout

\begin_layout Standard
As you can see, lines prefixed with '-' are executed but their results are
 not shown in the result, contrary to that, lines starting with '=' are
 executed and their result is interpolated in the template.
\end_layout

\begin_layout Standard
Haml doesn't only omit ending tags by indentation but the same mechanism
 also helps to the 'end' statements in embedded Ruby code.
 This way the HTML and Ruby languages are connected in their side-effects,
 providing you with a quite terse but still readable and DRY syntax to write
 your templates in.
\end_layout

\begin_layout Standard
There are downsides to this approach, as it's not possible to control how
 exactly the final document is generated, but Haml is gaining momentum in
 the Ruby community very fast despite that fact, as it's simply not important
 for most applications on the web.
\end_layout

\begin_layout Subsubsection*
Usage
\end_layout

\begin_layout LyX-Code
%html
\end_layout

\begin_layout LyX-Code
  %head
\end_layout

\begin_layout LyX-Code
    %title Hello, World!
\end_layout

\begin_layout LyX-Code
  %body
\end_layout

\begin_layout LyX-Code
    %h1 Hello, World!
\end_layout

\begin_layout LyX-Code
    - 10.times do |i|
\end_layout

\begin_layout LyX-Code
      %p= "#{ordinal(i)} times i've said hello"
\end_layout

\begin_layout Subsection
Sass
\end_layout

\begin_layout Standard
Haml is a templating engine for CSS, designed to make it both easier and
 more pleasant to create styles for your documents.
\end_layout

\begin_layout Standard
It attempts to eliminate redundancy, reflecting the underlying structure
 that CSS represents, and providing elegant, easily understandable but powerful
 syntax.
\end_layout

\begin_layout Standard
It's closely related to the Haml templating engine also supported by Ramaze.
\end_layout

\begin_layout Subsubsection*
Syntax
\end_layout

\begin_layout Subsubsection*
Usage
\end_layout

\begin_layout Subsection
Amrita2
\end_layout

\begin_layout Subsubsection*
Syntax
\end_layout

\begin_layout Subsubsection*
Usage
\end_layout

\begin_layout Subsection
Liquid
\end_layout

\begin_layout Subsubsection*
Syntax
\end_layout

\begin_layout Subsubsection*
Usage
\end_layout

\begin_layout Subsection
Markaby
\end_layout

\begin_layout Subsubsection*
Syntax
\end_layout

\begin_layout Subsubsection*
Usage
\end_layout

\begin_layout Subsection
Nagoro
\end_layout

\begin_layout Subsubsection*
Syntax
\end_layout

\begin_layout Subsubsection*
Usage
\end_layout

\begin_layout Subsection
None
\end_layout

\begin_layout Subsubsection*
Syntax
\end_layout

\begin_layout Subsubsection*
Usage
\end_layout

\begin_layout Subsection
RedCloth
\end_layout

\begin_layout Subsubsection*
Syntax
\end_layout

\begin_layout Subsubsection*
Usage
\end_layout

\begin_layout Subsection
Remarkably
\end_layout

\begin_layout Subsubsection*
Syntax
\end_layout

\begin_layout Subsubsection*
Usage
\end_layout

\begin_layout Subsection
Tagz
\end_layout

\begin_layout Subsubsection*
Syntax
\end_layout

\begin_layout Subsubsection*
Usage
\end_layout

\begin_layout Subsection
Tenjin
\end_layout

\begin_layout Subsubsection*
Syntax
\end_layout

\begin_layout Subsubsection*
Usage
\end_layout

\begin_layout Subsection
XSLT
\end_layout

\begin_layout Subsubsection*
Syntax
\end_layout

\begin_layout Subsubsection*
Usage
\end_layout

\begin_layout Subsection
How to create your own engine
\end_layout

\begin_layout Section
Ramaze::Adapter
\end_layout

\begin_layout Standard
Ramaze::Adapter is the module that contains and controls the various servers
 Ramaze runs on.
\end_layout

\begin_layout Standard
Adapters generally inherit from Ramaze::Adapter::Base, but are not instantiated,
 so singleton methods are used instead.
\end_layout

\begin_layout Subsection
Adapter::startup
\end_layout

\begin_layout Standard
The control flow in the Adapter module is largely decided by Global configuratio
n.
 Adapter::startup is called by Ramaze::start as Adapter is one of the elements
 in Ramaze.trait[:essentials].
\end_layout

\begin_layout Standard
Depending on the object assigned to Global.adapter
\end_layout

\begin_layout Subsection
How to create your own adapter
\end_layout

\begin_layout Standard
As usual, you might eventually end up having to create your own Adapter,
 either because there's none yet for the Server you are using or because
 you want a very particular set of options that you cannot supply otherwise.
 Fortunately this is a very simple thing to do, thanks to Rack and our Adapter::
Base.
\end_layout

\begin_layout Standard
We will take a look at one of the existing adapters for Mongrel first.
\end_layout

\begin_layout LyX-Code
\begin_inset External
	template RubyCode
	filename source/adapter/mongrel.rb

\end_inset


\end_layout

\begin_layout Standard
What we do here is putting a subclass of Ramaze::Adapter::Base into Ramaze::Adap
ter, so later Ramaze will be able to automatically find it (we will come
 to that later), but also because it is good practice.
\end_layout

\begin_layout Standard
This adapter only defines one method, ::startup.
 The host and port options from Global are passed to it when Adapter::startup
 invokes this method.
 If your adapter does not need these paramters it's common practice to default
 the parameters to nil, we'll see an example for this later as well when
 we come to discussing the CGI/Fcgi adapters.
\end_layout

\begin_layout Standard
Next we set the class instance variable @server, Adapters are not being
 initialized, we're only using singleton methods since there usually will
 only be one adapter active at a time.
\end_layout

\begin_layout Standard
Next we register the 
\begin_inset Quotes pld
\end_inset

/
\begin_inset Quotes prd
\end_inset

 path of the server with a Rack::Handler, what this exactly means is that
 the handler will take care of the nasty details and incompatibilities between
 different servers, providing a common interface to work with in Ramaze.
 
\begin_inset Quotes pld
\end_inset

/
\begin_inset Quotes prd
\end_inset

 means that it will handle every request, if you would define another path
 this would be handled separatly, usually you will want Ramaze to handle
 all requests.
\end_layout

\begin_layout Standard
Last, but not least we call @server.run, in Mongrel this means that it will
 return a new Thread in which the requests are handled.
 This is an essential detail, because Adapter::startup has to return a Thread.
 The reason for having a separate thread is to be able to run things in
 parallel, for example tests or specs.
 Whether or not the returned thread is called #join upon depends on the
 Global.run_loose option, which is false by default for normal applications,
 but defaults to true when you require 'ramaze/spec/helper'.
\end_layout

\begin_layout Standard
So let's see another adapter that uses one additional method.
\end_layout

\begin_layout Standard
\begin_inset External
	template RubyCode
	filename source/adapter/thin.rb

\end_inset


\end_layout

\begin_layout Standard
Thin is a server written in Ruby and C and follows an event based approach
 instead of a simple threaded TCPSocket.
\end_layout

\begin_layout Standard
What that means is that it won't spawn a Thread by default but work in the
 Thread::main scope, so this needs a bit of special care.
 It also uses a completely different API from Mongrel, although its parser
 is based on the Mongrel one.
\end_layout

\begin_layout Standard
Again we subclass Adapter::Base, define a method ::startup on it that takes
 host and port and define the @server variable, setting a couple of custom
 options and then create a new Thread in which we call @server.start, which
 would normally block further execution until an event like a browser request
 is received.
\end_layout

\begin_layout Standard
We also define the ::shutdown method, calling @server.stop, which will gracefully
 shut down the server, finishing any requests pending but not accepting
 new ones until all connections are closed.
\end_layout

\end_body
\end_document
